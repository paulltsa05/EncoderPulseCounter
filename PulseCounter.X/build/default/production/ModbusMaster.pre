
# 1 "ModbusMaster.c"

# 27 "crc16.h"
static uint16_t crc16_update(uint16_t crc, uint8_t a)
{
int i;

crc ^= a;
for (i = 0; i < 8; ++i)
{
if (crc & 1)
crc = (crc >> 1) ^ 0xA001;
else
crc = (crc >> 1);
}

return crc;
}

# 21 "word.h"
static inline uint16_t lowWord(uint32_t ww)
{
return (uint16_t) ((ww) & 0xFFFF);
}

# 33
static inline uint16_t highWord(uint32_t ww)
{
return (uint16_t) ((ww) >> 16);
}

static inline uint8_t highByte(uint16_t ww)
{
return (uint8_t) ((ww) >> 8);
}

static inline uint8_t lowByte(uint16_t ww)
{
return (uint8_t) ((ww) & 0xFF);
}

static inline bool bitRead(uint8_t ww,uint8_t pos)
{
return (bool) (((ww)>>pos) & 0x01);
}

# 29 "ModbusMaster.h"
void idle(void (*)());
void preTransmission(void (*)());
void postTransmission(void (*)());

# 46
static const uint8_t ku8MBIllegalFunction = 0x01;

# 66
static const uint8_t ku8MBIllegalDataAddress = 0x02;

# 81
static const uint8_t ku8MBIllegalDataValue = 0x03;

# 91
static const uint8_t ku8MBSlaveDeviceFailure = 0x04;

# 106
static const uint8_t ku8MBSuccess = 0x00;

# 115
static const uint8_t ku8MBInvalidSlaveID = 0xE0;

# 124
static const uint8_t ku8MBInvalidFunction = 0xE1;

# 134
static const uint8_t ku8MBResponseTimedOut = 0xE2;

# 143
static const uint8_t ku8MBInvalidCRC = 0xE3;

uint16_t getResponseBuffer(uint8_t);
void clearResponseBuffer();
uint8_t setTransmitBuffer(uint8_t, uint16_t);
void clearTransmitBuffer();

void beginTransmission(uint16_t);
uint8_t requestFrom(uint16_t, uint16_t);
void sendBit(bool);
void send8(uint8_t);
void send16(uint16_t);
void send32(uint32_t);
uint8_t available(void);
uint16_t receive(void);


uint8_t readCoils(uint16_t, uint16_t);
uint8_t readDiscreteInputs(uint16_t, uint16_t);
uint8_t readHoldingRegisters(uint16_t, uint16_t);
uint8_t readInputRegisters(uint16_t, uint8_t);
uint8_t writeSingleCoil(uint16_t, uint8_t);
uint8_t writeSingleRegister(uint16_t, uint16_t);
uint8_t writeMultipleCoils(uint16_t, uint16_t);
uint8_t writeMultipleCoils();
uint8_t writeMultipleRegisters(uint16_t, uint16_t);
uint8_t writeMultipleRegisters();
uint8_t maskWriteRegister(uint16_t, uint16_t, uint16_t);
uint8_t readWriteMultipleRegisters(uint16_t, uint16_t, uint16_t, uint16_t);
uint8_t readWriteMultipleRegisters(uint16_t, uint16_t);


uint8_t _u8MBSlave;
static const uint8_t ku8MaxBufferSize = 64;
uint16_t _u16ReadAddress;
uint16_t _u16ReadQty;
uint16_t _u16ResponseBuffer[ku8MaxBufferSize];
uint16_t _u16WriteAddress;
uint16_t _u16WriteQty;
uint16_t _u16TransmitBuffer[ku8MaxBufferSize];
uint16_t* txBuffer;
uint8_t _u8TransmitBufferIndex;
uint16_t u16TransmitBufferLength;
uint16_t* rxBuffer;
uint8_t _u8ResponseBufferIndex;
uint8_t _u8ResponseBufferLength;


static const uint8_t ku8MBReadCoils = 0x01;
static const uint8_t ku8MBReadDiscreteInputs = 0x02;
static const uint8_t ku8MBWriteSingleCoil = 0x05;
static const uint8_t ku8MBWriteMultipleCoils = 0x0F;


static const uint8_t ku8MBReadHoldingRegisters = 0x03;
static const uint8_t ku8MBReadInputRegisters = 0x04;
static const uint8_t ku8MBWriteSingleRegister = 0x06;
static const uint8_t ku8MBWriteMultipleRegisters = 0x10;
static const uint8_t ku8MBMaskWriteRegister = 0x16;
static const uint8_t ku8MBReadWriteMultipleRegisters = 0x17;


static const uint16_t ku16MBResponseTimeout = 2000;


uint8_t ModbusMasterTransaction(uint8_t u8MBFunction);


void (*_preTransmission)();

void (*_postTransmission)();

# 15 "ModbusMaster.c"
void ModbusMasterInit(uint8_t slave)
{
_idle = 0;
_preTransmission = 0;
_postTransmission = 0;
_u8MBSlave = slave;
_u8TransmitBufferIndex = 0;
u16TransmitBufferLength = 0;

# 28
}

void beginTransmission(uint16_t u16Address)
{
_u16WriteAddress = u16Address;
_u8TransmitBufferIndex = 0;
u16TransmitBufferLength = 0;
}


uint8_t requestFrom(uint16_t address, uint16_t quantity)
{
uint8_t read;

if (quantity > ku8MaxBufferSize)
{
quantity = ku8MaxBufferSize;
}

_u8ResponseBufferIndex = 0;
_u8ResponseBufferLength = read;

return read;
}


void sendBit(bool data)
{
uint8_t txBitIndex = u16TransmitBufferLength % 16;
if ((u16TransmitBufferLength >> 4) < ku8MaxBufferSize)
{
if (0 == txBitIndex)
{
_u16TransmitBuffer[_u8TransmitBufferIndex] = 0;
}
bitWrite(_u16TransmitBuffer[_u8TransmitBufferIndex], txBitIndex, data);
u16TransmitBufferLength++;
_u8TransmitBufferIndex = u16TransmitBufferLength >> 4;
}
}


void send16(uint16_t data)
{
if (_u8TransmitBufferIndex < ku8MaxBufferSize)
{
_u16TransmitBuffer[_u8TransmitBufferIndex++] = data;
u16TransmitBufferLength = _u8TransmitBufferIndex << 4;
}
}


void send32(uint32_t data)
{
send16(lowWord(data));
send16(highWord(data));
}


void send8(uint8_t data)
{
send16(((uint16_t)data)&0x00FF);
}

# 100
uint8_t available(void)
{
return _u8ResponseBufferLength - _u8ResponseBufferIndex;
}


uint16_t receive(void)
{
if (_u8ResponseBufferIndex < _u8ResponseBufferLength)
{
return _u16ResponseBuffer[_u8ResponseBufferIndex++];
}
else
{
return 0xFFFF;
}
}

# 130
void preTransmission(void (*preTransmission)())
{
_preTransmission = preTransmission;
}

# 148
void postTransmission(void (*postTransmission)())
{
_postTransmission = postTransmission;
}

# 162
uint16_t getResponseBuffer(uint8_t u8Index)
{
if (u8Index < ku8MaxBufferSize)
{
return _u16ResponseBuffer[u8Index];
}
else
{
return 0xFFFF;
}
}

# 181
void clearResponseBuffer()
{
uint8_t i;

for (i = 0; i < ku8MaxBufferSize; i++)
{
_u16ResponseBuffer[i] = 0;
}
}

# 201
uint8_t setTransmitBuffer(uint8_t u8Index, uint16_t u16Value)
{
if (u8Index < ku8MaxBufferSize)
{
_u16TransmitBuffer[u8Index] = u16Value;
return ku8MBSuccess;
}
else
{
return ku8MBIllegalDataAddress;
}
}

# 221
void clearTransmitBuffer()
{
uint8_t i;

for (i = 0; i < ku8MaxBufferSize; i++)
{
_u16TransmitBuffer[i] = 0;
}
}

# 255
uint8_t readCoils(uint16_t u16ReadAddress, uint16_t u16BitQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16BitQty;
return ModbusMasterTransaction(ku8MBReadCoils);
}

# 286
uint8_t readDiscreteInputs(uint16_t u16ReadAddress,
uint16_t u16BitQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16BitQty;
return ModbusMasterTransaction(ku8MBReadDiscreteInputs);
}

# 311
uint8_t readHoldingRegisters(uint16_t u16ReadAddress,
uint16_t u16ReadQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16ReadQty;
return ModbusMasterTransaction(ku8MBReadHoldingRegisters);
}

# 336
uint8_t readInputRegisters(uint16_t u16ReadAddress,
uint8_t u16ReadQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16ReadQty;
return ModbusMasterTransaction(ku8MBReadInputRegisters);
}

# 359
uint8_t writeSingleCoil(uint16_t u16WriteAddress, uint8_t u8State)
{
_u16WriteAddress = u16WriteAddress;
_u16WriteQty = (u8State ? 0xFF00 : 0x0000);
return ModbusMasterTransaction(ku8MBWriteSingleCoil);
}

# 379
uint8_t writeSingleRegister(uint16_t u16WriteAddress,
uint16_t u16WriteValue)
{
_u16WriteAddress = u16WriteAddress;
_u16WriteQty = 0;
_u16TransmitBuffer[0] = u16WriteValue;
return ModbusMasterTransaction(ku8MBWriteSingleRegister);
}

# 405
uint8_t writeMultipleCoils(uint16_t u16WriteAddress,
uint16_t u16BitQty)
{
_u16WriteAddress = u16WriteAddress;
_u16WriteQty = u16BitQty;
return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}
uint8_t writeMultipleCoils()
{
_u16WriteQty = u16TransmitBufferLength;
return ModbusMasterTransaction(ku8MBWriteMultipleCoils);
}

# 433
uint8_t writeMultipleRegisters(uint16_t u16WriteAddress,
uint16_t u16WriteQty)
{
_u16WriteAddress = u16WriteAddress;
_u16WriteQty = u16WriteQty;
return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}


uint8_t writeMultipleRegisters()
{
_u16WriteQty = _u8TransmitBufferIndex;
return ModbusMasterTransaction(ku8MBWriteMultipleRegisters);
}

# 471
uint8_t maskWriteRegister(uint16_t u16WriteAddress,
uint16_t u16AndMask, uint16_t u16OrMask)
{
_u16WriteAddress = u16WriteAddress;
_u16TransmitBuffer[0] = u16AndMask;
_u16TransmitBuffer[1] = u16OrMask;
return ModbusMasterTransaction(ku8MBMaskWriteRegister);
}

# 501
uint8_t readWriteMultipleRegisters(uint16_t u16ReadAddress,
uint16_t u16ReadQty, uint16_t u16WriteAddress, uint16_t u16WriteQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16ReadQty;
_u16WriteAddress = u16WriteAddress;
_u16WriteQty = u16WriteQty;
return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}
uint8_t readWriteMultipleRegisters(uint16_t u16ReadAddress,
uint16_t u16ReadQty)
{
_u16ReadAddress = u16ReadAddress;
_u16ReadQty = u16ReadQty;
_u16WriteQty = _u8TransmitBufferIndex;
return ModbusMasterTransaction(ku8MBReadWriteMultipleRegisters);
}

# 534
uint8_t ModbusMasterTransaction(uint8_t u8MBFunction)
{
uint8_t u8ModbusADU[256];
uint8_t u8ModbusADUSize = 0;
uint8_t i, u8Qty;
uint16_t u16CRC;
uint32_t u32StartTime;
uint8_t u8BytesLeft = 8;
uint8_t u8MBStatus = ku8MBSuccess;


u8ModbusADU[u8ModbusADUSize++] = _u8MBSlave;
u8ModbusADU[u8ModbusADUSize++] = u8MBFunction;

switch(u8MBFunction)
{
case ku8MBReadCoils:
case ku8MBReadDiscreteInputs:
case ku8MBReadInputRegisters:
case ku8MBReadHoldingRegisters:
case ku8MBReadWriteMultipleRegisters:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadAddress);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadAddress);
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16ReadQty);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16ReadQty);
break;
}

switch(u8MBFunction)
{
case ku8MBWriteSingleCoil:
case ku8MBMaskWriteRegister:
case ku8MBWriteMultipleCoils:
case ku8MBWriteSingleRegister:
case ku8MBWriteMultipleRegisters:
case ku8MBReadWriteMultipleRegisters:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteAddress);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteAddress);
break;
}

switch(u8MBFunction)
{
case ku8MBWriteSingleCoil:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
break;

case ku8MBWriteSingleRegister:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
break;

case ku8MBWriteMultipleCoils:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
u8Qty = (_u16WriteQty % 8) ? ((_u16WriteQty >> 3) + 1) : (_u16WriteQty >> 3);
u8ModbusADU[u8ModbusADUSize++] = u8Qty;
for (i = 0; i < u8Qty; i++)
{
switch(i % 2)
{
case 0:
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i >> 1]);
break;

case 1:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i >> 1]);
break;
}
}
break;

case ku8MBWriteMultipleRegisters:
case ku8MBReadWriteMultipleRegisters:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16WriteQty);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16WriteQty << 1);

for (i = 0; i < lowByte(_u16WriteQty); i++)
{
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[i]);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[i]);
}
break;

case ku8MBMaskWriteRegister:
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[0]);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[0]);
u8ModbusADU[u8ModbusADUSize++] = highByte(_u16TransmitBuffer[1]);
u8ModbusADU[u8ModbusADUSize++] = lowByte(_u16TransmitBuffer[1]);
break;
}


u16CRC = 0xFFFF;
for (i = 0; i < u8ModbusADUSize; i++)
{
u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
}
u8ModbusADU[u8ModbusADUSize++] = lowByte(u16CRC);
u8ModbusADU[u8ModbusADUSize++] = highByte(u16CRC);
u8ModbusADU[u8ModbusADUSize] = 0;



if(PIR1bits.RCIF){PIR1bits.RCIF=1;}


if (_preTransmission)
{
_preTransmission();
}
for (i = 0; i < u8ModbusADUSize; i++)
{
EUSART_Write(u8ModbusADU[i]);
}

u8ModbusADUSize = 0;

if (_postTransmission)
{
_postTransmission();
}



while (u8BytesLeft && !u8MBStatus)
{

# 669
u8ModbusADU[u8ModbusADUSize++] = EUSART_Read();
u8BytesLeft--;

# 690
if (u8ModbusADUSize == 5)
{

if (u8ModbusADU[0] != _u8MBSlave)
{
u8MBStatus = ku8MBInvalidSlaveID;
break;
}


if ((u8ModbusADU[1] & 0x7F) != u8MBFunction)
{
u8MBStatus = ku8MBInvalidFunction;
break;
}


if (bitRead(u8ModbusADU[1], 7))
{
u8MBStatus = u8ModbusADU[2];
break;
}


switch(u8ModbusADU[1])
{
case ku8MBReadCoils:
case ku8MBReadDiscreteInputs:
case ku8MBReadInputRegisters:
case ku8MBReadHoldingRegisters:
case ku8MBReadWriteMultipleRegisters:
u8BytesLeft = u8ModbusADU[2];
break;

case ku8MBWriteSingleCoil:
case ku8MBWriteMultipleCoils:
case ku8MBWriteSingleRegister:
case ku8MBWriteMultipleRegisters:
u8BytesLeft = 3;
break;

case ku8MBMaskWriteRegister:
u8BytesLeft = 5;
break;
}
}
if ((millis() - u32StartTime) > ku16MBResponseTimeout)
{
u8MBStatus = ku8MBResponseTimedOut;
}
}


if (!u8MBStatus && u8ModbusADUSize >= 5)
{

u16CRC = 0xFFFF;
for (i = 0; i < (u8ModbusADUSize - 2); i++)
{
u16CRC = crc16_update(u16CRC, u8ModbusADU[i]);
}


if (!u8MBStatus && (lowByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 2] ||
highByte(u16CRC) != u8ModbusADU[u8ModbusADUSize - 1]))
{
u8MBStatus = ku8MBInvalidCRC;
}
}


if (!u8MBStatus)
{

switch(u8ModbusADU[1])
{
case ku8MBReadCoils:
case ku8MBReadDiscreteInputs:

for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
{
if (i < ku8MaxBufferSize)
{
_u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 4], u8ModbusADU[2 * i + 3]);
}

_u8ResponseBufferLength = i;
}


if (u8ModbusADU[2] % 2)
{
if (i < ku8MaxBufferSize)
{
_u16ResponseBuffer[i] = word(0, u8ModbusADU[2 * i + 3]);
}

_u8ResponseBufferLength = i + 1;
}
break;

case ku8MBReadInputRegisters:
case ku8MBReadHoldingRegisters:
case ku8MBReadWriteMultipleRegisters:

for (i = 0; i < (u8ModbusADU[2] >> 1); i++)
{
if (i < ku8MaxBufferSize)
{
_u16ResponseBuffer[i] = word(u8ModbusADU[2 * i + 3], u8ModbusADU[2 * i + 4]);
}

_u8ResponseBufferLength = i;
}
break;
}
}

_u8TransmitBufferIndex = 0;
u16TransmitBufferLength = 0;
_u8ResponseBufferIndex = 0;
return u8MBStatus;
}
